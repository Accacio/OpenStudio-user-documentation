<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Measure Writing Guide - OpenStudio User Docs</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../../favicon.ico">
    
    <link href="../../css/bootstrap-3.3.0.min.css" rel="stylesheet">
    <link href="../../css/font-awesome-4.2.0.min.css" rel="stylesheet">
    <link href="../../css/prettify-1.0.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
  <nav class="navbar navbar-default" role="navigation">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../.."><img alt="" src="../../img/OS_32x32.png"> OpenStudio User Docs</a>
      </div>
      <div class="navbar-collapse collapse">
        <!-- Main navigation -->
        <ul class="nav navbar-nav">
        
          
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-hover="dropdown" data-toggle="dropdown">Getting Started <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
            
              <li>
                <a href="../../getting_started/features">Current Features</a>
              </li>
            
              <li>
                <a href="../../getting_started/roadmap">Planned Features</a>
              </li>
            
              <li>
                <a href="../../getting_started/getting_started">Installation and Introductory Tutorial</a>
              </li>
            
            </ul>
          </li>
          
        
          
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-hover="dropdown" data-toggle="dropdown">References & Tutorials <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
            
              <li>
                <a href="../../next_steps/quick_start_guides">Quick Start Guides</a>
              </li>
            
              <li>
                <a href="../../next_steps/sketchup_plugin_interface">SketchUp Plug-in</a>
              </li>
            
              <li>
                <a href="../../next_steps/openstudio_application_interface">OpenStudio Application</a>
              </li>
            
              <li>
                <a href="../../next_steps/model_objects">Overview of OpenStudio Model Objects</a>
              </li>
            
              <li>
                <a href="../../next_steps/creating_your_model">Creating Your Model</a>
              </li>
            
              <li>
                <a href="../../next_steps/running_your_simulation">Running Your Simulation & Viewing Results</a>
              </li>
            
              <li>
                <a href="../../next_steps/life_cycle_costing_examples">Life Cycle Costing Examples</a>
              </li>
            
              <li>
                <a href="../../next_steps/detailed_tutorials/tutorial_glhepro">GLHEPro Tutorial</a>
              </li>
            
              <li>
                <a href="../../next_steps/detailed_tutorials/tutorial_shadingcontrols">Shading Controls Tutorial</a>
              </li>
            
            </ul>
          </li>
          
        
          
          <li class="dropdown active">
            <a href="#" class="dropdown-toggle" data-hover="dropdown" data-toggle="dropdown">Measures <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
            
              <li>
                <a href="../about_measures">About Measures</a>
              </li>
            
              <li class="active">
                <a href=".">Measure Writing Guide</a>
              </li>
            
              <li>
                <a href="../measure_code_examples">Measure Code Examples</a>
              </li>
            
            </ul>
          </li>
          
        
          
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-hover="dropdown" data-toggle="dropdown">Comparative Analysis <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
            
              <li>
                <a href="../../comparative_analysis/parametric_studies">ParametricAnalysisTool</a>
              </li>
            
              <li>
                <a href="../../comparative_analysis/large_scale_analysis">Large Scale Analysis</a>
              </li>
            
            </ul>
          </li>
          
        
          
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-hover="dropdown" data-toggle="dropdown">Help <span class="caret"></span></a>
            <ul class="dropdown-menu" role="menu">
            
              <li>
                <a href="../../help/training">Training</a>
              </li>
            
              <li>
                <a href="../../help/finding_model_data">Finding Model Data</a>
              </li>
            
              <li>
                <a href="../../help/best_practices">Best Practices</a>
              </li>
            
              <li>
                <a href="../../help/troubleshooting">Troubleshooting</a>
              </li>
            
              <li>
                <a href="../../help/faq">FAQ</a>
              </li>
            
              <li>
                <a href="../../help/software_license">Software License</a>
              </li>
            
            </ul>
          </li>
          
        
        </ul>

        <!-- Search, Navigation and Repo links -->
        <ul class="nav navbar-nav navbar-right">
        
        </ul>
      </div>
    </div>
  </nav>
</div>
    <div class="container">
      <div class="row">
        <div class="col-md-3">
          <div class="bs-docs-sidebar hidden-print affix well" role="complementary">
  <ul class="nav">
  
    <li class="main active"><a href="#what-is-a-measure">What is a Measure?</a>
      <ul class="nav">
        
      </ul>
    </li>
  
    <li class="main"><a href="#using-this-guide">Using this Guide</a>
      <ul class="nav">
        
      </ul>
    </li>
  
    <li class="main"><a href="#measure-file-measurerb">Measure File - measure.rb</a>
      <ul class="nav">
        
        <li><a href="#starting-and-ending-the-measure">Starting and Ending the Measure</a></li>
        
        <li><a href="#name">Name</a></li>
        
        <li><a href="#description">Description</a></li>
        
        <li><a href="#modeler-description">Modeler Description</a></li>
        
        <li><a href="#arguments">Arguments</a></li>
        
        <li><a href="#run">Run</a></li>
        
      </ul>
    </li>
  
    <li class="main"><a href="#measure-file-measurexml">Measure File - measure.xml</a>
      <ul class="nav">
        
        <li><a href="#provenance">Provenance</a></li>
        
        <li><a href="#tags">Tags</a></li>
        
        <li><a href="#attributes">Attributes</a></li>
        
      </ul>
    </li>
  
    <li class="main"><a href="#advanced-topics">Advanced Topics</a>
      <ul class="nav">
        
        <li><a href="#energyplus-measures">EnergyPlus Measures</a></li>
        
        <li><a href="#reporting-measures">Reporting Measures</a></li>
        
        <li><a href="#output-attributes">Output Attributes</a></li>
        
      </ul>
    </li>
  
  </ul>
  <div class="home-btn">
    <a class="btn btn-default" role="button" href="https://www.openstudio.net">Back to OpenStudio</a>
  </div>
</div>
        </div>
        <div class="col-md-9" role="main">
          <h1>Measure Writing Guide</h1>

<p>This guide goes through the details of an OpenStudio Measure, focusing mainly on writing new Measures and understanding existing Measures.</p>
<h2 id="what-is-a-measure">What is a Measure?</h2>
<p>In building design and retrofits, the terms <em>energy efficiency measure</em> (EEM) and <em>energy conservation measure</em> (ECM) refer to a specific change that can be made to a building to reduce its energy use. As an example, if you are retrofitting an existing building and one of the ECMs suggested by the design team is "Add continuous insulation to the walls", then you can run that measure to quickly alter your model.</p>
<p>In OpenStudio, a measure is a set of programmatic instructions (such as an Excel macro) that makes changes to an energy model to reflect its application. In our example, the measure might find the construction used by exterior wall surfaces in the model and add a layer of continuous insulation. Measures can be written specifically for an individual model, or they may be more generic to work on a wide range of possible models.</p>
<!--- DLM: we need a link to how to create, copy, and update measures in the app and PAT-->

<p>OpenStudio measures may be created using either the OpenStudio Application or the Parametric Analysis Tool. Measures can be created from scratch or may be copied from another measure as a starting point. Users should use either the OpenStudio Application or PAT to create measures, copying files directly in the file system is not supported.</p>
<h2 id="using-this-guide">Using this Guide</h2>
<p>Each OpenStudio measure is contained in its own folder (usually named after the measure) and contains two key files:</p>
<ul>
<li>measure.rb (contains the programmatic code to change the building mode)</li>
<li>measure.xml (contains information about the measure that allows other people to search for and find it).</li>
</ul>
<p>The measure may also contain tests to ensure that it works correctly and resources which are other files that the measure uses during its operation. This file structure allows OpenStudio to easily share and use measures.</p>
<p><img alt="guide image" src="../../img/measure-writing-guide/1.png" /></p>
<p>This guide is directed primarily toward measure authors; some instructions also apply to users.</p>
<p>This guide explains the purpose of each of these files and walks through their contents step-by-step to help you create your own measures. The programming instructions for each measure are written in a programming language called Ruby (http://www.ruby-lang.org/en/). If you are unfamiliar with the basic concepts of computer programming, it would be wise to acquire some background (preferably in the Ruby language, http://tryruby.org) before proceeding. That said, the Ruby code in these examples is simple, so anyone familiar with basic programming concepts (variables, loops, etc.) should be able to read this guide with little difficulty.</p>
<p>The types of files we discuss can be opened in a text editor (notepad++ is a free editor that works well for these examples, http://notepad-plus-plus.org/). File content appears in boxes to differentiate it from the rest of the text. Ellipses (...) represent code that was removed because it is not relevant to the current discussion.</p>
<pre><code>a = 5
...
</code></pre>

<h2 id="measure-file-measurerb">Measure File - measure.rb</h2>
<p>The measure.rb file contains the Ruby program that allows the measure to make changes to the input model. The bulk of the work done when writing a measure lies in editing this file. The measure.rb file includes the beginning and end of the measure; the content of the measure is then divided into three general sections:  name, arguments, and run. The following sections explain each section.</p>
<h3 id="starting-and-ending-the-measure">Starting and Ending the Measure</h3>
<p>Generally, each measure is a variation of an OpenStudio ModelUserScript. You do not need to worry about what this means right now; we will explain the details later. The important point is that the text below starts and ends a measure. The class name for the measure (in light blue) is user defined. The same class name appears again on the last line where a new instance of the class is instantiated and registered with OpenStudio. It is good practice to use UpperCamelCase (CapitalizeTheFirstLetterOfEveryWord) for your class name. This must be a valid class name in Ruby; it must start with an uppercase letter and cannot contain spaces or other special characters. Everything else about the measure (name, arguments, and run) will be inserted where the ellipsis is.</p>
<!--- DLM: should we explain model, e+, and reporting measures here or later?-->

<pre><code class="ruby">class AddContinuousInsulationToWalls &lt; OpenStudio::Ruleset::ModelUserScript
  ...
end

AddContinuousInsulationToWalls.new.registerWithApplication
</code></pre>

<h3 id="name">Name</h3>
<p>The measure's Name should be written such that another building professional (architect, engineer, etc.) can quickly understand what the measure will do when searching through a list of measures. This name is intended to be used in automatically generated reports. For example, in a table of energy savings by measure this name would identify each measure.</p>
<pre><code class="ruby">def name
  return &quot;Add Continuous Insulation to Walls&quot;
end
</code></pre>

<p>Best practice measure names will be explicit about what they do, particularly with respect to whether they add, change, replace, or remove things from the model. Compare specific names such as:</p>
<ul>
<li>Replace HVAC System with DX and Natural Gas AHUs</li>
<li>Add Continuous Insulation to Walls</li>
<li>Remove all Electric Equipment in Specified Space Types</li>
</ul>
<p>With vague names like:</p>
<ul>
<li>DX and Natural Gas AHUs</li>
<li>Insulate Walls</li>
<li>Modify Electric Equipment</li>
</ul>
<p>Remember that the measure name is the first contact a user has with the measure. If the name is vague or misleading, it is detrimental to sharing and likely will not be used often.</p>
<h3 id="description">Description</h3>
<p>The Description should explain what the measure does in terms that general building professionals (architects, engineers, contractors, etc.) can understand. This description is intended to be used in energy modeling reports that persuade the design team to implement the measure in the actual building design. The  Description is written for a general audience and should not assume that the reader is familiar with the construction and design practices suggested by the measure. Thus, the Description may include details about how the measure would be implemented, along with explanations of associated qualitative benefits. It is good practice to include citations in the measure if the description is taken from a known source or if specific benefits are listed.</p>
<!---DLM: what voice should be used here?  is there a standard?-->

<!---DLM: should description take the user args and allow substitution of values the user passed?-->

<pre><code class="ruby">def description
  return &quot;Add a layer of continuous insulation between the framing members and exterior cladding. This insulation layer is in addition to any bat insulation installed between framing members. Continuous insulation must be installed without thermal bridges other than fasteners and service openings, adding continuous insulation to a design may require longer fasteners. For more information please see &lt;a href='http://fsc.americanchemistry.com/Exterior-Walls/Continuous-Insulation-Educational-Presentation.pdf'&gt;here&lt;/a&gt;.&quot;
end
</code></pre>

<h3 id="modeler-description">Modeler Description</h3>
<p>The Modeler Description is intended for the energy modeler using the measure. It should explain how the measure is modeled, including any requirements about how the baseline model must be set up, major assumptions made by the measure, citations of references to applicable modeling resources, etc. The energy modeler should be able to read this description and understand the changes the measure is making to the model and why. The Modeler Description is written for an expert audience and can assume that the reader is familiar with common modeling practices. This description is intended to be used in automatically generated reports. For example, in an appendix describing each the modeling approach of each measure considered for an energy savings study this description would be printed for each measure.</p>
<!---DLM: what voice should be used here?  is there a standard?-->

<!---DLM: should modeler_description take the user args and allow substitution of values the user passed?-->

<pre><code class="ruby">def modeler_description
  return &quot;This measure will search through all constructions used on exterior walls. For each construction, if the second material layer is of type OS:Material:NoMass, then that layer will be assumed to be existing continuous insulation and will be replaced by the material layer specified in this measure. If the second layer is not of type OS:Material:NoMass, then a new material layer will be inserted at the second material layer position. If any non-exterior wall surfaces use this construction, it will be cloned before being altered and the altered construction will be hard assigned to the appropriate exterior wall surfaces.&quot;
end
</code></pre>

<h3 id="arguments">Arguments</h3>
<p>Inside this method, you describe which, if any, input parameters the user should be able to change before running the measure. In the example "Add Continuous Insulation to Walls", you might want the user to specify the thickness of the insulation along with the R-value per inch of thickness. When a measure has input parameters that the user can edit, the user can change the input values to perform a parametric analysis to answer "what-if" questions and find the best option.</p>
<p>The arguments section opens and closes as follows:</p>
<pre><code class="ruby">def arguments(model)
  args = OpenStudio::Ruleset::OSArgumentVector.new
  ...
  return args
end
</code></pre>

<p>On the first line, you start the method and pass in the model, in case the arguments presented to the user are model dependent. For example, if the user can only choose from air loops in the model, you should present only valid air loop names. The second line sets the variable that will hold the arguments the user can edit. The last line passes these arguments back to the user to fill out.</p>
<p>In our example, you might want to give the user two inputs:  insulation thickness and R-value per inch of insulation. The argument for insulation thickness would look like this:</p>
<pre><code class="ruby">insl_thckn = OpenStudio::Ruleset::makeDoubleArgument('insl_thckn',true)
insl_thckn.setDisplayName('Insulation Thickness (in)')
insl_thckn.setDefaultValue(1.5)
args &lt;&lt; insl_thckn
</code></pre>

<p>The first line is a command to create a new argument of the type double (more on the arguments types later) and assign it to the variable "insl_thckn". The "true" at the end of this line indicates that the argument is required; "false" indicates that the argument is not required. On the second line, the display name of the argument is set. The user will see this in the graphical user interface (GUI). It is good practice to identify the units of the argument inside parentheses at the end of the display name so the user knows what value to input. On the third line, you specify the default value for the argument. This default value is presented initially to the user, but the user can change the value in the GUI.</p>
<h4 id="types-of-arguments">Types of Arguments</h4>
<p>You can create a few types of arguments</p>
<h5 id="double">Double</h5>
<p>A double argument is any real number such as 1.0, -1.5, or 50.5.</p>
<pre><code class="ruby">v1 = OpenStudio::Ruleset::OSArgument::makeDoubleArgument('v1', false)
</code></pre>

<h5 id="integer">Integer</h5>
<p>An integer argument is any real whole number such as 1, -2, or 51.</p>
<pre><code class="ruby">v2 = OpenStudio::Ruleset::OSArgument::makeIntegerArgument('v2', false)
</code></pre>

<h5 id="boolean-bool">Boolean (Bool)</h5>
<p>A boolean argument gives the user the choices of true or false.</p>
<pre><code class="ruby">v3 = OpenStudio::Ruleset::OSArgument::makeBoolArgument('v3', false)
</code></pre>

<h5 id="string">String</h5>
<p>A string argument allows the user to input text.</p>
<pre><code class="ruby">v4 = OpenStudio::Ruleset::OSArgument::makeStringArgument('v4', false)
</code></pre>

<h5 id="choice">Choice</h5>
<p>A choice argument allows you to limit the user to picking from a set list of options. For the choice argument, you must create the choices and pass them into the argument.</p>
<pre><code class="ruby">chs = OpenStudio::StringVector.new
chs &lt;&lt; &quot;Option 1&quot;
chs &lt;&lt; &quot;Option 2&quot;
v5 = OpenStudio::Ruleset::OSArgument::makeChoiceArgument('v5', chs, true)
</code></pre>

<p>Possible values for the choice arguments can also be extracted from the model. For example, the following would give the user a choice of any zones in the model, by zone name.</p>
<pre><code class="ruby">v6 = OpenStudio::Ruleset::makeChoiceArgumentOfWorkspaceObjects
          (&quot;v6&quot;,&quot;OS_Thermal_Zone&quot;.to_IddObjectType,model,true)
</code></pre>

<h4 id="defaults-and-required-arguments">Defaults and Required Arguments</h4>
<p>When deciding how to ask the user for each input, you should consider whether the input is required and whether there is a reasonable default value. Required arguments are inputs that the measure needs to run, such as the lighting level for each space. Non-required arguments are optional, but you must make clear to the user what will happen if no value is provided. Default values may be based on current best practices (e.g., current lighting power reductions to 0.8 W/ft2 are possible), or they may be chosen specifically for the model (e.g., choose the most common space type for adjusting the lighting power). Where the argument is not required but there is a good default, it is good practice to set the argument to be required anyway, as there is no burden on the user to provide any input.</p>
<table>
<thead>
<tr>
<th>Required?</th>
<th>Has a Default?</th>
<th>Best Practice?</th>
</tr>
</thead>
<tbody>
<tr>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>No</td>
<td>No</td>
<td>Must be documented</td>
</tr>
</tbody>
</table>
<h3 id="run">Run</h3>
<p>The run method is where all the magic happens. This is where you write the programmatic instructions that take the user inputs and change the energy model in specific ways. This method has more pieces than the name or arguments method. We explain each piece separately, and then show all the pieces together.</p>
<p>The run method starts much like the other methods:</p>
<pre><code class="ruby">def run(model, runner, user_arguments)
  super(model, runner, user_arguments)
  ...
  return true
end
</code></pre>

<p>The super line is boilerplate; it is necessary, but you do not need to worry about how it works. Just before the end to the run method there should be a "return true" line. If a measure does not return "true," OpenStudio will think that the measure failed and the simulation workflow will stop.</p>
<h4 id="input-validation">Input Validation</h4>
<p>When the user applies a measure to a model, he or she first fills in the inputs the author exposed in the arguments method. Because the user may have entered bad values, you first need to validate the input in the run method. For example, the user may have indicated that the building is 1 ft long instead of 100 ft long, or the input asked for an integer and the user input 2.5. Regardless, you must check the inputs before moving forward.</p>
<p>The first step is to make sure that each required argument appears, has a value, and the value is the right type (strings are strings, doubles are doubles, etc.). This part of the error checking is built into OpenStudio and is shown below. If the argument fails to validate, this built-in method will give the user specific error messages that describe the problem. The second line is "return false."  This tells the run method to stop here; "false" indicates that the measure's run method did not complete successfully.</p>
<pre><code class="ruby">if not runner.validateUserArguments(arguments(model), user_arguments)
  return false
end
</code></pre>

<p>Assuming that all the required inputs are present and have the right kinds of values, you next need to ensure that values make sense in the context of the script. For example, -2 is a valid integer, but it is not a valid number of chillers in a building.</p>
<p>The first step in this type of error checking is to pull the values from the "user_arguments" variable and assign them to variables in the run method. Best practice is to use the same variable names in the arguments method and the run method.</p>
<pre><code class="ruby">v1 = runner.getDoubleArgumentValue('v1',user_arguments)
v2 = runner.getIntegerArgumentValue('v2',user_arguments)
v3 = runner.getBoolArgumentValue('v3',user_arguments)
v4 = runner.getStringArgumentValue('v4',user_arguments)
v5 = runner.getStringArgumentValue('v5',user_arguments)
v6 = runner.getOptionalWorkspaceObjectChoiceValue('v6',user_arguments, model)
</code></pre>

<p>Now that the user inputs have been assigned to variables, you need to check the validity of each value. If you encounter a problem, you need a way to let the user know what happened (and how to fix it). We will now take a brief detour to explain how you can pass this type of information back to the user. We will then continue on with input validation.</p>
<h4 id="info-warning-and-error-messages">Info, Warning, and Error Messages</h4>
<p>You can send three types of messages to the user from the measure. These messages will be shown in the GUI when the measure is run. You can thus let the user know something, but does not need to force the user to go into obscure error and output files. Each message has a specific purpose. The messages below are short for clarity; however, there is no limit to the length of the messages passed. Best practice messages will be concise, yet specific enough that the user knows exactly where to go to address any issue.</p>
<h5 id="info-messages">Info Messages</h5>
<p>Info messages simply let the user know what happened as the measure was running. Info messages do not cause the measure to fail or stop running. In our example of "Add Continuous Insulation to Walls", you might decide to tell the user the number of surfaces to which insulation was added. In Ruby, inserting "#{num_surfaces}" in the message tells Ruby to convert the value of the variable "num_surfaces" to a string and substitute the result into the message.</p>
<pre><code class="ruby">runner.registerInfo(&quot;Added insulation to #{num_surfaces} surfaces.&quot;)
</code></pre>

<h5 id="warning-messages">Warning Messages</h5>
<p>Warning messages enable you to warn the user about something that may be critical to the assumptions or that significantly affects how the measure runs. Warning messages do not cause the measure to stop running. In our example of "Add Continuous Insulation to Walls", you might want to warn the user if the insulation thickness entered exceeds 12 inches, because adding more than 12 inches of insulation is unusual but not unheard of.</p>
<pre><code class="ruby">runner.registerWarning(&quot;#{insul_thckns} inches of insulation seems high.&quot;)
</code></pre>

<h5 id="error-messages">Error Messages</h5>
<p>Error messages are used when the measure simply cannot continue. Perhaps the user entered
-1.5 for a fractional schedule value. Error messages stop the measure from running. Error messages should point the user to the specific error and suggest a way to fix or avoid it. The measure should return "false" and issue an error message:</p>
<pre><code class="ruby">runner.registerError(&quot;v1 must be greater than or equal to 0 and less than or equal to 1.  You entered #{v1}.&quot;)

return false
</code></pre>

<h4 id="input-validation-continued">Input Validation (Continued)</h4>
<p>Now that we have covered how to send information messages back to the user, we will continue discussing how to validate the input. In this first example, we assume that v1 is a fractional value; therefore, it must be between 0 and 1.</p>
<pre><code class="ruby">if v1 &lt; 0 or v1 &gt; 1
  runner.registerError(&quot;v1 must be greater than or equal to 0 and less than or equal to 1.  You entered #{v1}.&quot;)
  return false
end
</code></pre>

<p>This error checking is performed with a Ruby if statement. If the input check test fails,  an error message is registered, and then the measure's run method returns "false," stopping the measure from continuing.</p>
<p>Input validation can be as simple or as detailed as the situation requires. The goal is to catch any bad inputs before wasting time making nonsensical changes to the model and alert the user of the problem so it can be corrected as quickly as possible.</p>
<h4 id="making-changes-to-the-model">Making Changes to the Model</h4>
<p>Once all the inputs have been checked, it is time to start doing something to the model. A vast number of possible changes can be made, so rather than describing each one, this section gives a few examples and explains how to determine which commands to use to do other things.</p>
<p>The goal of the first example will be to loop through all the spaces in the model and check whether the space is assigned to a thermal zone. If it not assigned to a thermal zone, you need to create a new thermal zone and assign this space to it.</p>
<pre><code class="ruby">def run(model, runner, user_arguments)
  super(model,runner,user_arguments)
  spaces = model.getSpaces

  spaces.each do |space|
    if space.thermalZone.empty?
      new_thermal_zone = OpenStudio::Model::ThermalZone.new(model)
      space.setThermalZone(new_thermal_zone)
      runner.registerInfo(&quot;Space #{space.name} didn't have a thermal zone,
                          so a new thermal zone was created and assigned.&quot;)
    end
  end

end
</code></pre>

<p>The first command is to get all the spaces in the model. Whenever you want a vector of a certain class of objects from a model, the command is "get#{ClassName}s" (e.g., getThermalZones, getSpaces). Next you start a loop that iterates through all spaces in the model. Within this loop the next command checks to see if the space has a thermal zone assigned. Now you begin to get into the programming weeds... be patient, this is one of the hardest parts to understand.</p>
<h4 id="optionals-and-get">Optionals and .get</h4>
<p>OpenStudio is written in C++, and translated to be available in Ruby by software called SWIG. This auto-translation leaves one artifact that Ruby users generally do not deal with:  the "optional" return type.</p>
<p>Some OpenStudio methods return an "OptionalSomething" (Ruby hint: if you ever want to know the type of a variable in Ruby, you can use the ".class" method to find out). An optional result is either empty (the method did not return anything) or it points to what you are trying to get. Look at the example line.</p>
<pre><code class="ruby">if space.thermalZone.empty?
</code></pre>

<p>In the online <a href="http://openstudio.nrel.gov/sites/openstudio.nrel.gov/files/nv_data/cpp_documentation/model/html/classopenstudio_1_1model_1_1_space.html">documentation</a> for the "Space" object, the method ".thermalZone" is defined as:</p>
<p>boost::optional&lt;<a href="http://openstudio.nrel.gov/sites/openstudio.nrel.gov/files/nv_data/cpp_documentation_it/model/html/classopenstudio_1_1model_1_1_thermal_zone.html">ThermalZone</a>&gt; openstudio::model::Space::thermalZone( ) const</p>
<p>This indicates that calling "space.thermalZone" returns a "boost::optional&lt; <a href="http://openstudio.nrel.gov/sites/openstudio.nrel.gov/files/nv_data/cpp_documentation_it/model/html/classopenstudio_1_1model_1_1_thermal_zone.html">ThermalZone</a> &gt;" result. Ignoring the syntax for now, the main point is that the method returns an "OptionalThermalZone" and not a "ThermalZone". To learn whether this "OptionalThermalZone" points to an actual "ThermalZone," you use the ".empty?" method. If the result is empty, it does not point to an actual "ThermalZone" and cannot be used. In the example if "space.thermalZone.empty?" is true, the space has no thermal zone. Calling "get" on an empty "OptionalSomething" will crash the measure.</p>
<p>If an "OptionalSomething" is not empty, it points to an actual "Something" and can be used. To get the actual "Something" that the variable points to, you can use the ".get" method. In the example if "space.thermalZone.empty?" is not true, you can use ".get" to get a reference to the space's thermal zone.</p>
<pre><code class="ruby">if not space.thermalZone.empty?
  thermal_zone = space.thermalZone.get
end
</code></pre>

<p>The OpenStudio API has many places where optional results are returned. The API documentation can be very helpful for determining the type of result a given method returns. Several methods in OpenStudio return a "ModelObject" (".clone", ".optionalWorkspaceObjectChoiceValue", etc.). This is fine for many purposes; however, if you want to test if the object returned is of a particular type (e.g., is it a Space or a SpaceType), you will have to try converting the object to those types using the ".to_#{ClassName}"  (".to_Space", ".to_SpaceType", etc). Those methods will return an optional result, which will be empty if the conversion failed and will contain the value if it succeeded. If the conversion was successful, you can use all the methods of that type on the result.</p>
<pre><code class="ruby">new_object = old_object.clone(model)
if not new_object.to_LightsDefinition.empty?
  #what you cloned was a LightsDefinition
  new_light_def = new_object.to_LightsDefinition.get
else
  #what you cloned was not a LightsDefinition
end
</code></pre>

<p>Don't worry if you did not understand all this on the first pass, keep going forward and look at the next example, referring back as needed.</p>
<h4 id="info-warning-and-error-messages-continued">Info, Warning, and Error Messages (Continued)</h4>
<p>Beyond the info, warning, and error messages that you can give to the user, three other specific pieces of information can be returned:  the initial condition, the final condition, and whether the measure was applicable to this particular model.</p>
<h5 id="initial-condition">Initial Condition</h5>
<p>The initial condition is a way for you to give the user a "before" snapshot of the model with respect to what the measure will change. Reporting the initial condition is optional, but is good practice.</p>
<pre><code class="ruby">runner.registerInitialCondition(&quot;Model started with #{num_flrs} floors&quot;)
</code></pre>

<h5 id="final-condition">Final Condition</h5>
<p>The final condition is a way for you to give the user an "after" snapshot of the model with respect to what the measure changed. Reporting the final condition is optional, but is good practice. The initial and final conditions can be useful when explaining the specific changes the measure made to the model.</p>
<pre><code class="ruby">runner.registerFinalCondition(&quot;Model ended with #{num_flrs} floors&quot;)
</code></pre>

<h5 id="not-applicable">Not Applicable</h5>
<p>Not all measures are applicable to all models. For example, a measure called "Replace all windows with triple-paned windows" would not be applicable to a building with no windows. The fact that a measure ran successfully, but made no changes to the model, should be recorded. Imagine that the user applied the example measure to many buildings and looked at its impact across all the buildings. For the building with no windows, the measure was "Not Applicable", so the user could therefore exclude this building from the impact analysis. It is good practice to track whether a measure makes any changes to the model, and register it as "Not Applicable" if no changes were made.</p>
<pre><code class="ruby">runner.registerAsNotApplicable(&quot;Measure not applicable because XYZ&quot;)
return true
</code></pre>

<p>This extended example shows how the initial condition, final condition, and applicability flags are used.</p>
<pre><code class="ruby">def run(model, runner, user_arguments)
  super(model,runner,user_arguments)
  spaces = model.getSpaces

  num_spcs_with_tz = 0
  num_spcs_no_tz = 0
  num_tzs_created = 0

  spaces.each do |space|
    if space.thermalZone.empty?
      num_spcs_no_tz += 1
      new_thermal_zone = OpenStudio::Model::ThermalZone.new(model)
      num_tzs_created += 1
      space.setThermalZone(new_thermal_zone)
      runner.registerInfo(&quot;Space #{space.name} didn't have a thermal zone,
                          so a new thermal zone was created and assigned.&quot;)
    else
      num_spcs_with_tz += 1
    end
  end

  runner.registerInitialCondition(&quot;The model had #{num_spcs_with_tz}
                                  spaces with a thermal zone and
                                 #{num_spcs_no_tz} without a thermal zone&quot;)

  runner.registerFinalCondition(&quot;#{num_tzs_created} thermal zones were
                                 created. All spaces now have a thermal
                                 zone&quot;)

  if num_tzs_created == 0
    runner.registerAsNotApplicable(&quot;Not applicable because all spaces
                                    already had thermal zones&quot;)
  end

  return true
end
</code></pre>

<h4 id="what-methods-are-available">What Methods Are Available?</h4>
<p>After looking at the examples above, you might be thinking "I understand the structure of a measure, but what if I want to write a measure that does something besides add thermal zones to spaces?"  This is a good question.</p>
<p>The next example illustrates the process of going from an idea for a measure through writing the measure, assuming little behind-the-scenes knowledge of OpenStudio.</p>
<h5 id="the-idea">The Idea</h5>
<p>Write a measure that will remove all lights currently in the "Enclosed Office" space type and replace them with new lights that have a lighting power density (LPD) of 10 W/m2.</p>
<h5 id="figuring-out-the-modeling-approach">Figuring Out the Modeling Approach</h5>
<p>The first thing to do is understand how the measure would be modeled in OpenStudio, and make a list of the objects involved. The easiest way to do this is to open the OpenStudio Application and look through the GUI. In this case, we'll start on the "Space Types" tab.</p>
<p><img alt="guide image2" src="../../img/measure-writing-guide/2.png" /></p>
<p>On this tab, first click on the first object (in the left column) is "Space Type."  Inside the Space Type, next to the lights icon, the term "Definition" appears. The name of this particular definition is "ASHRAE_90.1-2004_Office_LPD."  To learn more about this definition, go to the "Loads" tab.</p>
<p><img alt="Guide image3" src="../../img/measure-writing-guide/3.png" /></p>
<p>On the left side under the "Loads" tab is a category called "Lights Definitions."  Under this category is the definition "ASHRAE_90.1-2004_Office_LPD" that was referenced on the "Space Types" tab. One field is titled "Energy Per Space Floor Area" with units of "W/ft2."  Although the GUIs may show IP units, the methods of the OpenStudio model are all written in SI units.</p>
<h5 id="restating-the-measure-using-openstudio-terms">Restating the Measure Using OpenStudio Terms</h5>
<p>Restate the measure using the names of the OpenStudio model objects found during the GUI exploration:</p>
<p>Find the SpaceType called "Enclosed Office". Replace any LightsDefinitions referenced by Lights in this SpaceType with a new LightsDefinition having "Energy Per Space Floor Area" = 10 W/m2.</p>
<h5 id="finding-the-openstudio-methods-using-the-documentation">Finding the OpenStudio Methods: Using the Documentation</h5>
<p>All the OpenStudio code documentation lives online at https://s3.amazonaws.com/openstudio-sdk-documentation/index.html. <a href="https://s3.amazonaws.com/openstudio-sdk-documentation/index.html">Open this website.</a></p>
<p><img alt="Methods 1" src="../../img/measure-writing-guide/4.png" /></p>
<p>Click on the model link to explore.</p>
<p><img alt="Methods 2" src="../../img/measure-writing-guide/5.png" /></p>
<p>This will take you to the OpenStudio Model Overview page.</p>
<p><img alt="Core" src="../../img/measure-writing-guide/6.png" /></p>
<p>Select the "Objects/Objects List" to find more information on individual model objects.
<img alt="Core" src="../../img/measure-writing-guide/6b.png" /></p>
<p>Click "<strong>SpaceType</strong>"."</p>
<p><img alt="click space" src="../../img/measure-writing-guide/7.png" /></p>
<p>This screen contains the documentation for the SpaceType class. The methods are generally split into four categories: Constructors and Destructors, Getters, Setters, and Other. SpaceType is a base class of ResourceObject. You can look into the ResourceObject for additional methods beyond what is in the SpaceType documentation.</p>
<h6 id="understanding-the-methods">Understanding the Methods</h6>
<p>At first glance, the methods look cryptic, not at all like those shown in the examples, because this is the C++ documentation and the methods used are the Ruby translation of these same methods. These methods can be decoded as follows:</p>
<p>The name of the method:</p>
<p><img alt="name of method" src="../../img/measure-writing-guide/8.png" /></p>
<p>The method names are generally descriptive enough that it is possible to understand what they do without any other information. Here is how the method would be used in Ruby:</p>
<pre><code class="ruby">design_spec_oa = space_type.designSpecificationOutdoorAir
</code></pre>

<p>The type of object returned by the method:</p>
<p><img alt="type of object" src="../../img/measure-writing-guide/9.png" /></p>
<p>Methods Return Types:</p>
<p>bool = true/false</p>
<p>double = a number</p>
<p>std::string = text</p>
<p>void = does not return anything</p>
<p>std::vector<InternalMass> = A vector of the type of objects inside the &lt;&gt;; in this case the Ruby class returned will be a InternalMassVector.</p>
<p>boost::optional<DesignSpecificationOutdoorAir> = an optional that may either be empty or point to an actual object of the type inside the &lt;&gt;; in this case the Ruby class returned will be an Optional DesignSpecificationOutdoorAir. See the section <a href="#345-optionals-and-get">Optionals and .get</a> for more information about optional types.</p>
<p>The written description of the method:</p>
<p><img alt="description" src="../../img/measure-writing-guide/10.png" /></p>
<p>The inputs needed by the method:</p>
<p><img alt="inputs" src="../../img/measure-writing-guide/11.png" /></p>
<p>Methods that do not need inputs have empty parentheses (). Ruby allows you to skip adding the empty parentheses when you call methods with no arguments. You can ignore the const and &amp; C++ keywords in the declarations for now.</p>
<h5 id="using-the-documentation-for-the-example-measure">Using the Documentation for the Example Measure</h5>
<p>With an understanding of how to read the documentation, the example measure continues.</p>
<p>The first step is to find the SpaceType called "Enclosed Office". As you loop through all the spaces in the model, you can use the ".name" method to get the name of each space. Note that the ".name" method returns an "OptionalString"; however,  OpenStudio will assign names to all model objects, so there is no need to check if the name is empty before using it. You can use the ".match" method to see if the SpaceType's name matches the value you are looking for.</p>
<pre><code class="ruby">space_types = model.getSpaceTypes
space_types.each do |space_type|
  if space_type.name.get.match(&quot;Enclosed Office&quot;)
    #do something
  end
end
</code></pre>

<p>Once you have found a SpaceType matching the name you are looking for, you need to get all the Lights in Spaces of this SpaceType. The documentation for SpaceType includes a method to get a vector of all Lights in Spaces of this SpaceType:</p>
<p><img alt="Space Matching" src="../../img/measure-writing-guide/12.png" /></p>
<p>You can extend the code to then loop over all these Lights:</p>
<pre><code class="ruby">space_types = model.getSpaceTypes
space_types.each do |space_type|
  if space_type.name.get.match(&quot;Enclosed Office&quot;)
    space_type.lights.each do |light|
      #do something
    end
  end
end
</code></pre>

<p>Now you need to make a new LightsDefinition to replace the ones these Lights currently use. The documentation for LightsDefinition shows a constructor that expects a Model as the input.</p>
<p><img alt="Lights def" src="../../img/measure-writing-guide/13.png" /></p>
<p>Constructors translated from C++ to Ruby take the following form. The only difference may be which arguments the constructor requires; usually it is simply a Model.</p>
<pre><code class="ruby">new_thing = OpenStudio::Model::NewThingClassName.new(model)
</code></pre>

<p>Now, figure out how to set the LPD of the LightsDefinition to 10 W/m2. The LightsDefinition documentation presents a method.</p>
<p><img alt="lights def2" src="../../img/measure-writing-guide/14.png" /></p>
<p>You will also want to name the new LightsDefinition object for better user comprehension. Most OpenStudio objects have a ".setName(new_name)" method. You can put this together to make the LightsDefinition object.</p>
<pre><code class="ruby">new_lights_def = OpenStudio::Model::LightsDefinition.new(model)
new_lights_def.setWattsperSpaceFloorArea(10.0)
new_lights_def.setName(&quot;10 W/m^2 Lights Definition&quot;)
</code></pre>

<p>Now that you have a new LightsDefinition object, you need to figure out how to replace the existing LightsDefinition with the new one. The Lights documentation contains a method to set the lights definition.</p>
<p><img alt="Replace Existing" src="../../img/measure-writing-guide/15.png" /></p>
<p>Putting this all together, we get:</p>
<pre><code class="ruby">new_lights_def = OpenStudio::Model::LightsDefinition.new(model)
new_lights_def.setWattsperSpaceFloorArea(10.0)
new_lights_def.setName(&quot;10 W/m^2 Lights Definition&quot;)

space_types = model.getSpaceTypes
space_types.each do |space_type|
  if space_type.name.match(&quot;Enclosed Office&quot;)
    lights = space_type.lights
    lights.each do |light|
      light.setLightsDefinition(new_lights_def)
    end
  end
end
</code></pre>

<h4 id="putting-it-all-together">Putting It All Together</h4>
<p>The following example is a complete measure.rb file, including all the pieces described previously. Notice that there are comments in this script. It is good practice to include comments directly inside the measure.rb file, so anyone who opens the file can understand what is happening. These comments were omitted from the previous examples because the main text described what was happening.</p>
<pre><code class="ruby"># a pound sign denotes a comment
</code></pre>

<pre><code class="ruby">#start the measure
class ReplaceLightsInSpaceTypeWithLPD &lt; OpenStudio::Ruleset::ModelUserScript

  #define the name that a user will see
  def name
    return &quot;Replace All Lights in a Given Space Type with a New LPD&quot;
  end

  #define the arguments that the user will input
  def arguments(model)
    args = OpenStudio::Ruleset::OSArgumentVector.new

    #make an argument for space type name
    stn = OpenStudio::Ruleset::OSArgument::makeStringArgument('stn',true)
    stn.setDisplayName('Space Type Name')
    args &lt;&lt; stn

    #make an argument for LPD
    lpd = OpenStudio::Ruleset::OSArgument::makeDoubleArgument('lpd',true)
    lpd.setDisplayName('Lighting Power Density (W/m^2)')
    lpd.setDefaultValue(1.0)
    args &lt;&lt; lpd

    return args
  end #end the arguments method

  #define what happens when the measure is run
  def run(model, runner, user_arguments)
    super(model, runner, user_arguments)

    #use the built-in error checking
    if not runner.validateUserArguments(arguments(model), user_arguments)
      return false
    end

    #assign the user inputs to variables
    stn = runner.getStringArgumentValue('stn',user_arguments)
    lpd = runner.getDoubleArgumentValue('lpd',user_arguments)

   #check the LPD for reasonableness
    if lpd &lt; 0 or lpd &gt; 100 #error on impossible values
      runner.registerError(&quot;Lighting Power Density (W/m^2) must be
                              greater than 0 and less than 100.
                              You entered #{lpd}.&quot;)
      return false
    elsif lpd &gt; 50 #warning on unrealistic but possible values
      runner.registerWarning(&quot;A Lighting Power Density of #{lpd} W/m^2
                              seems a little high.  Measure will continue,
                              but double-check this isn't a typo.&quot;)
    end

    #create a variable and array for tracking changes to model
    num_spctyp_changed = 0
    spctyp_ch_log = []

    #make changes to the model
    #loop through all space types in the model
    model.getSpaceTypes.each do |space_type|
      if space_type.name.get.match(&quot;#{stn}&quot;)
        num_spctyp_changed += 1 #log change
        runner.registerInfo(&quot;Space Type called #{space_type.name} matches
                            #{stn}.&quot;)
        #loop through all lights in the space type
        space_type.lights.each do |light|
          #get the old lpd from the existing lights definition, if exists
          old_lpd = &quot;not per-area&quot;
          if not light.lightsDefinition.wattsperSpaceFloorArea.empty?
            old_lpd = light.lightsDefinition.wattsperSpaceFloorArea.get
          end
          #add the old and new condition to the change log
          spctyp_ch_log &lt;&lt; [space_type.name, old_lpd]
          #make a new lights definition
          new_lights_def = OpenStudio::Model::LightsDefinition.new(model)
          new_lights_def.setWattsperSpaceFloorArea(lpd)
          new_lights_def.setName(&quot;#{lpd} W/m^2 Lights Definition&quot;)
          #replace the old lights def with the new lights def
          light.setLightsDefinition(new_lights_def)
        end
      end
    end

    #report out the initial and final condition to the user
    initial_condition = &quot;&quot;
    initial_condition &lt;&lt; &quot;There are #{num_spctyp_changed} space types
                                    that match the name #{stn}.  &quot;
    final_condition = &quot;&quot;
    spctyp_ch_log.each do |ch|
      initial_condition &lt;&lt; &quot;Space type #{ch[0]} had an lpd of #{ch[1]}
                            W/m^2. &quot;
      final_condition &lt;&lt; &quot;space type #{ch[0]}, &quot;
    end
    final_condition &lt;&lt; &quot;were all set to an lpd of #{lpd} W/m^2&quot;
    runner.registerInitialCondition(initial_condition)
    runner.registerFinalCondition(final_condition)

    #report if the measure was Not Applicable
    if num_spctyp_changed == 0
      runner.registerAsNotApplicable(&quot;Not Applicable -
                                      No space types matched #{stn}.&quot;)
    end

    return true
  end #end the run method

end #end the measure

#boilerplate that allows the measure to be use by the application
ReplaceLightsInSpaceTypeWithLPD.new.registerWithApplication
</code></pre>

<h2 id="measure-file-measurexml">Measure File - measure.xml</h2>
<p>The measure.xml file contains metadata that allow the measure to be filed into an organizational structure, provide an explanation about what the measure does and how it works, and tell the GUI where in the workflow the measure can go. The GUI creates a new measure.xml file when you click on the "Create a New Measure" button. In general, you should not need to make any changes to the measure.xml file manually. The OpenStudio Application and PAT detect any changes that are made to measures in your "My Measures" directory when you press the "Sync Project Measures with Library" button. Changes to the name, description, modeler description or any other measure properties will be updated in the measure and the measure will be given a new version identifier. However, there are a few limited cases when you will need to modify the measure.xml file by hand. These cases are 1) changing the measure's author information (i.e. provenance), 2) changing the tags which determine where the measure is listed in the BCL measure taxonomy, 3) changing attributes which are used when searching for the measure on the BCL. To make changes to any of these items you will have to edit the appropriate section (described below) in the measure.xml file by hand, then press the "Sync Project Measures with Library" button in either the OpenStudio Application or PAT to assign a new version identifier.</p>
<h3 id="provenance">Provenance</h3>
<p>The Provenance section describes who wrote the measure and when. As author, you may identify yourself however you desire; current convention is to use first initial of first name, followed by full last name (Andrew Parker -&gt; aparker). You may name multiple authors. The time format follows ISO 8601 (http://en.wikipedia.org/wiki/ISO_8601).</p>
<pre><code class="xml">&lt;provenances&gt;
  &lt;provenance&gt;
    &lt;author&gt;aparker&lt;/author&gt;
    &lt;datetime&gt;2013-01-28T15:00:00Z&lt;/datetime&gt;
  &lt;/provenance&gt;
  &lt;provenance_required&gt;true&lt;/provenance_required&gt;
&lt;/provenances&gt;
</code></pre>

<h3 id="tags">Tags</h3>
<p>The Tags section describes where the measure lives in the BCL Measure taxonomy. This taxonomy is used to indicate where in the GUI the measure should be displayed. If the Tags section is blank, the measure will not show up in the GUI.</p>
<h4 id="bcl-measures-taxonomy">BCL Measures Taxonomy</h4>
<p>The BCL Measures Taxonomy is available at http://bcl.nrel.gov/api/taxonomy/measure, the current taxonomy is:</p>
<ul>
<li>Envelope<ul>
<li>Fenestration</li>
<li>Daylighting</li>
<li>Form</li>
<li>Infiltration</li>
<li>Opaque</li>
</ul>
</li>
<li>Electric Lighting<ul>
<li>Controls</li>
<li>Lighting Equipment</li>
</ul>
</li>
<li>Equipment<ul>
<li>Controls</li>
<li>Electric Equipment</li>
</ul>
</li>
<li>HVAC<ul>
<li>Controls</li>
<li>Heating</li>
<li>Cooling</li>
<li>Heat Rejection</li>
<li>Energy Recovery</li>
<li>Distribution</li>
<li>Ventilation</li>
<li>Whole System</li>
</ul>
</li>
<li>Refrigeration</li>
<li>Service Water Heating<ul>
<li>Water Use</li>
<li>Water Heating</li>
<li>Distribution</li>
</ul>
</li>
<li>Onsite Power Generation<ul>
<li>Photovoltaic</li>
</ul>
</li>
<li>Reporting<ul>
<li>QAQC</li>
<li>Troubleshooting</li>
</ul>
</li>
</ul>
<p>The place inside the measure taxonomy is indicated Level1.level2. An example is Envelope.Fenestration.</p>
<pre><code class="xml">&lt;tags&gt;
  &lt;tag&gt;Envelope.Fenestration&lt;/tag&gt;
&lt;/tags&gt;
</code></pre>

<h3 id="attributes">Attributes</h3>
<p>The Attributes section gives additional metadata that allow the GUI to display the measure in the correct place in the workflow and show only measures that can be used by a particular tool. There are currently two standardized attributes used for measures "Intended Software Tool" and "Intended Use Case", these are populated when a new measure is created. If you wish to change these after the measure has been created you must edit the measure.xml file manually. Other attributes may be added but are not used by OpenStudio applications.</p>
<!--- DLM: at some point we might want to create a list of measure attributes similar to the component ones https://bcl.nrel.gov/list-of-attributes -->

<h4 id="intended-software-tool">Intended Software Tool</h4>
<p>The Intended Software Tool attribute lists the tools that this measure is intended to be used by. Software tools may choose to only display measures which list them as an intended software tool. A measure can list more than one tool as intended software tool. The list of software tools used by OpenStudio is:</p>
<ul>
<li>Apply Measure Now - measures intended to be run directly on the current model in the OpenStudio Application. Only Model measures may be used in the Apply Measure Now feature.</li>
<li>OpenStudio Application - measures intended to be run as part of the simulation workflow in the OpenStudio Application.</li>
<li>Parametric Analysis Tool - measures intended to be run as part of the simulation workflow in PAT.</li>
<li>Analysis Spreadsheet - measures intended to be run on the cloud using the OpenStudio Analysis Spreadsheet.</li>
</ul>
<!--- DLM: I forgot all the details about which things are which, need to review with David and Nick -->

<p>Example xml:</p>
<pre><code class="xml">&lt;attributes&gt;
  &lt;attribute&gt;
    &lt;name&gt;Intended Software Tool&lt;/name&gt;
    &lt;value&gt;Apply Measure Now&lt;/value&gt;
    &lt;datatype&gt;string&lt;/datatype&gt;
  &lt;/attribute&gt;
  &lt;attribute&gt;
    &lt;name&gt;Intended Software Tool&lt;/name&gt;
    &lt;value&gt;OpenStudio Application&lt;/value&gt;
    &lt;datatype&gt;string&lt;/datatype&gt;
  &lt;/attribute&gt;
&lt;/attributes&gt;
</code></pre>

<h4 id="intended-use-case">Intended Use Case</h4>
<p>The Intended Use Case attribute describes the typical scenarios that this measure will be used in. Software tools may choose to only display measures which apply to their intended use case. A measure can list more than one intended use case. The list of use cases used by OpenStudio is:</p>
<!--- DLM: I forgot all the details about which things are which, need to review with David and Nick -->

<!--- DLM: Do we need a standards use case? For things that require standards markup?-->

<ul>
<li>Model Articulation - measures which create building modeling content. Examples include a building geometry footprint generator or a measure that adds an HVAC system to a model which does not have one.</li>
<li>Calibration - measures which alter an existing model for the purposes of calibration. Examples include measures which fine tune infiltration levels or adjust existing lighting power to account for uncertainty in operational schedules.</li>
<li>Sensitivity Analysis - measures which alter an existing model to determine what parameters are most sensitive. Examples include a measure which makes all walls adiabatic or a measure which removes all lights from the building.</li>
<li>New Construction EE - measures which are appropriate energy conservation measures for new construction applications. Examples include increased framing depth or reduced window to wall ratio.</li>
<li>Retrofit EE - measures which are appropriate energy conservation measures for retrofit applications. Examples include replacing incandescent light fixtures with high efficiency T-8s or adding occupancy sensors to uncommonly used spaces.</li>
<li>Automatic Report Generation - measures which report human or machine readable content. Examples include a report showing total floor area per space type or a report which plots energy use as a function of outdoor temperature.</li>
</ul>
<p>Example xml:</p>
<pre><code class="xml">&lt;attributes&gt;
  &lt;attribute&gt;
    &lt;name&gt;Intended Use Case&lt;/name&gt;
    &lt;value&gt;Model Articulation&quot;&lt;/value&gt;
    &lt;datatype&gt;string&lt;/datatype&gt;
  &lt;/attribute&gt;
  &lt;attribute&gt;
    &lt;name&gt;Intended Use Case&lt;/name&gt;
    &lt;value&gt;New Construction EE&lt;/value&gt;
    &lt;datatype&gt;string&lt;/datatype&gt;
  &lt;/attribute&gt;
&lt;/attributes&gt;
</code></pre>

<h2 id="advanced-topics">Advanced Topics</h2>
<h3 id="energyplus-measures">EnergyPlus Measures</h3>
<p>Measures are usually written to work on an OpenStudio model. This is preferred because it allows you to use the OpenStudio Model API, which includes specialized methods for each type of object in the OpenStudio Model. However, when a particular EnergyPlus feature is not yet exposed in the OpenStudio Model, you may choose to write a measure that operates on the EnergyPlus data model directly. Measures of this type are run only after the model is translated from OpenStudio to EnergyPlus.</p>
<p>Below are some specific code differences for EnergyPlus versus. Model (OpenStudio) measures.</p>
<p>The class line should refer to "WorkspaceScript" versus "ModelScript", as shown in the following example:</p>
<pre><code class="ruby">class ConstructionTakeOff &lt; OpenStudio::Ruleset::WorkspaceUserScript
</code></pre>

<p>The argument will take a "workspace" in place of "model".</p>
<pre><code class="ruby">def arguments(workspace)
</code></pre>

<p>Similar to argument, the "run" method also takes a "Workspace" in place of a "Model".</p>
<pre><code class="ruby">def run(workspace, runner, user_arguments)
  super(workspace, runner, user_arguments)
</code></pre>

<p>The API available to work with EnergyPlus objects directly is simpler than the OpenStudio Model API; it allows for changing .idf fields directly, getting all objects of a certain type, etc. This functionality is [documented][10] under the utilities project in the classes "Workspace" and "WorkspaceObject".</p>
<h4 id="finding-and-inspecting-energyplus-objects">Finding and Inspecting EnergyPlus Objects</h4>
<p>The following example shows how to find and loop through EnergyPlus objects. You can find objects in an EnergyPlus Workspace based on their IDD type (e.g., "BuildingSurface:Detailed"). These types can be found in the EnergyPlus documentation shown in Section 5.4. The IDF model is not an object model. As a result, instead of requesting a name we access specific fields by index in the IDD, starting at 0 and going up, such as ".getString(2)".</p>
<pre><code class="ruby">  #get all surfaces and constructions in model
  heat_transfer_surfaces = workspace.getObjectsByType(&quot;BuildingSurface:Detailed&quot;.to_IddObjectType)
  #the line below won't get other objects such as Construction:InternalSource.
  constructions = workspace.getObjectsByType(&quot;Construction&quot;.to_IddObjectType)

  #report initial condition
  runner.registerInitialCondition(&quot;The model has #{constructions.size} construction objects.&quot;)

  #array for constructions that are used on a heat transfer surface
  used_constructions_names = [] #just holds names

  #get names of constructions used in the model
  heat_transfer_surfaces.each do |heat_transfer_surface|
    construction = heat_transfer_surface.getString(2).to_s #(0) is name, (1) is Surface Type, etc.
    used_constructions_names &lt;&lt; construction
  end
</code></pre>

<h4 id="adding-energyplus-workspace-objects">Adding EnergyPlus Workspace Objects</h4>
<p>The following example shows how to add a new EnergyPlus object into the Workspace. A string is created, using Ruby's string substitution mechanisms to set variable values, and then the string is turned into IdfObject and finally added to the Workspace.</p>
<pre><code class="ruby">  #array to hold new IDF objects
  string_objects = []

  #loop through constructions adding ComponentCost:LineItem for each
  used_constructions_names.sort.uniq.each do |used_construction_name|
  #.unig will only loop through unique values in an array

    #IDF object text for ComponentCost:LineItem
    string_objects &lt;&lt; &quot;
      ComponentCost:LineItem,
        #{used_construction_name}_TakeOff,    !- Name
        ,                                     !- Type
        Construction,                         !- Line Item Type
        #{used_construction_name},            !- Item Name
        ,                                     !- Object End Use Key
        ,                                     !- Cost per Each {$}
        0.000000000001;                       !- Cost per Area {$/m2}
        &quot;
  end

  #add all of the strings to workspace to create IDF objects
  string_objects.each do |string_object|
    idfObject = OpenStudio::IdfObject::load(string_object)
    object = idfObject.get
    wsObject = workspace.addObject(object)
  end
</code></pre>

<h4 id="editing-energyplus-workspace-objects">Editing EnergyPlus Workspace Objects</h4>
<p>The following example shows how to access and edit EnergyPlus objects in the Workspace.</p>
<pre><code class="ruby">  #get OutputControl:Table:Style object that was generated in forward translation from OSM to IDF
  table_style = workspace.getObjectsByType(&quot;OutputControl:Table:Style&quot;.to_IddObjectType)

  #even though there is just a single object, it is still in an array
  if not table_style.empty?
    # we can access the first object in the array using table_style[0]
    if table_units == &quot;Inch-Pound&quot;
      #use setString to change the field value to request IP units
      table_style_ip = table_style[0].setString(1,&quot;InchPound&quot;)
    else
      #will result in SI units in tables
      table_style_si = table_style[0].setString(1,&quot;&quot;)
    end
  end
</code></pre>

<h4 id="finding-documentation-on-energyplus-objects">Finding Documentation on EnergyPlus Objects</h4>
<p>The "[InputOutputReference.pdf][11]" document that ships with EnergyPlus describes every EnergyPlus object. Below is a screenshot of part of the documentation for the "ComponentCost:LineItem" object. It describes which fields are required versus optional, and what kinds of data are expected for each field. EnergyPlus also ships with example models that show each object being used in a model. In the "Examples" folder is a spreadsheet that documents the examples.</p>
<p><img alt="Finding Doc" src="../../img/measure-writing-guide/17.png" /></p>
<h4 id="putting-it-all-together-a-complete-workspaceuserscript">Putting It All Together - A Complete WorkspaceUserScript</h4>
<p>The script creates a ComponentCost:LineItem object for each construction used in the model.</p>
<pre><code class="ruby">#start the measure
class ConstructionTakeOff &lt; OpenStudio::Ruleset::WorkspaceUserScript

  #define the name that a user will see
  def name
    return &quot;Create Envelope Quantity TakeOff&quot;
  end

  #define the arguments that the user will input
  def arguments(workspace)
    args = []

    #make an argument for table units
    chs = OpenStudio::StringVector.new
    chs &lt;&lt; &quot;Inch-Pound&quot;
    chs &lt;&lt; &quot;SI Units&quot;
    table_units = OpenStudio::Ruleset::OSArgument::makeChoiceArgument(&quot;table_units&quot;,chs)
    table_units.setDisplayName(&quot;Choose Units for EnergyPlus Output HTML&quot;)
    table_units.setDefaultValue(&quot;Inch-Pound&quot;)
    args &lt;&lt; table_units

    return args
  end #end the arguments method

  #define what happens when the measure is run
  def run(workspace, runner, user_arguments)
    super(workspace, runner, user_arguments)

    #assign the user inputs to variables
    table_units = runner.getStringArgumentValue(&quot;table_units&quot;,user_arguments)

    #get all surfaces and constructions in model
    heat_transfer_surfaces = workspace.getObjectsByType(&quot;BuildingSurface:Detailed&quot;.to_IddObjectType)
    #the line below won't get other objects such as Construction:InternalSource.
    constructions = workspace.getObjectsByType(&quot;Construction&quot;.to_IddObjectType)

    #report initial condition
    runner.registerInitialCondition(&quot;The model has #{constructions.size} construction objects.&quot;)

    #array for constructions that are used on a heat transfer surface
    used_constructions_names = [] #just holds names

    #get names of constructions used in the model
    heat_transfer_surfaces.each do |heat_transfer_surface|
      construction = heat_transfer_surface.getString(2).to_s #(0) is name, (1) is Surface Type, etc.
      used_constructions_names &lt;&lt; construction
    end
    #report as not applicable if there are no constructions in the model used on surfaces.
    if used_constructions_names.empty?
      runner.registerAsNotApplicable(&quot;There are not any constructions in the model that are associated with surfaces.&quot;)
    end

    #array to hold new IDF objects
    string_objects = []

    #loop through constructions adding ComponentCost:LineItem for each
    used_constructions_names.sort.uniq.each do |used_construction_name| #.unig will only loop through unique values in an array

      #IDF object text for ComponentCost:LineItem
      string_objects &lt;&lt; &quot;
        ComponentCost:LineItem,
          #{used_construction_name}_TakeOff,    !- Name
          ,                                     !- Type
          Construction,                         !- Line Item Type
          #{used_construction_name},            !- Item Name
          ,                                     !- Object End Use Key
          ,                                     !- Cost per Each {$}
          0.000000000001;                       !- Cost per Area {$/m2}
          &quot;
    end

    #add all of the strings to workspace to create IDF objects
    string_objects.each do |string_object|
      idfObject = OpenStudio::IdfObject::load(string_object)
      object = idfObject.get
      wsObject = workspace.addObject(object)
    end

    #report final condition about objects added to the model
    runner.registerFinalCondition(&quot;ComponentCost:LineItem objects were added for the #{used_constructions_names.uniq.size} constructions that are used in the model.&quot;)

    #if IP unites requested add OutputControl:Table:Style object
    table_style = workspace.getObjectsByType(&quot;OutputControl:Table:Style&quot;.to_IddObjectType)

    #even though there is just a single object, it is still in an array
    if not table_style.empty?
      # we can access the first object in the array using table_style[0]
      if table_units == &quot;Inch-Pound&quot;
        #use setString to change the field value to request IP units
        table_style_ip = table_style[0].setString(1,&quot;InchPound&quot;)
      else
        #will result in SI units in tables
        table_style_si = table_style[0].setString(1,&quot;&quot;)
      end
        end

  end #end the run method

end #end the measure

#this allows the measure to be use by the application
ConstructionTakeOff.new.registerWithApplication
</code></pre>

<h3 id="reporting-measures">Reporting Measures</h3>
<p>After running a simulation with OpenStudio a large amount of data is available. However, this data is not in a format that can be easily explored and understood. This is where Reporting Measures come in. Reporting Measures run after the EnergyPlus simulation to extract data and reformat it in useful ways. Reporting Measures can extract machine readable attributes for a large automated analysis. Reporting Measures can also produce interactive, human readable html reports that include plots and charts.</p>
<h4 id="energyplus-output-requests">EnergyPlus Output Requests</h4>
<p>There is a special method, available for reporting measures only, which allows reporting measures to request EnergyPlus output variables which are required by the run method. This feature is necessary to ensure that output the measure needs for reports will be present in the simulation output. This method takes in the runner and user arguments, it returns a vector of IdfObjects that request the required outputs, these objects will be added to the Idf before simulation. However, only certain types of IdfObjects may be requested, these are:</p>
<ul>
<li>Output:Surfaces:List</li>
<li>Output:Surfaces:Drawing</li>
<li>Output:Schedules</li>
<li>Output:Constructions</li>
<li>Output:Table:TimeBins</li>
<li>Output:Table:Monthly</li>
<li>Output:Variable</li>
<li>Output:Meter</li>
<li>Output:Meter:MeterFileOnly</li>
<li>Output:Meter:Cumulative</li>
<li>Output:Meter:Cumulative:MeterFileOnly</li>
<li>Meter:Custom</li>
<li>Meter:CustomDecrement</li>
<li>Output:Table:SummaryReports (unique object)</li>
</ul>
<p>Duplicate requests will be ignored and in the case of unique objects, the requests will be merged with requests in the existing model.</p>
<pre><code class="ruby">  def energyPlusOutputRequests(runner, user_arguments)
    super(runner, user_arguments)

    result = OpenStudio::IdfObjectVector.new

    # use the built-in error checking
    if !runner.validateUserArguments(arguments(), user_arguments)
      return result
    end

    result &lt;&lt; OpenStudio::IdfObject.load(&quot;Output:Variable,,Site Outdoor Air Drybulb Temperature,Timestep;&quot;).get
    result &lt;&lt; OpenStudio::IdfObject.load(&quot;Output:Variable,,Site Outdoor Air Humidity Ratio,Timestep;&quot;).get
    result &lt;&lt; OpenStudio::IdfObject.load(&quot;Output:Variable,,Site Outdoor Air Relative Humidity,Timestep;&quot;).get

    result &lt;&lt; OpenStudio::IdfObject.load(&quot;Output:Variable,,Zone Air Temperature,Timestep;&quot;).get
    result &lt;&lt; OpenStudio::IdfObject.load(&quot;Output:Variable,,Zone Air Humidity Ratio,Timestep;&quot;).get
    result &lt;&lt; OpenStudio::IdfObject.load(&quot;Output:Variable,,Zone Air Relative Humidity,Timestep;&quot;).get

    return result
  end
</code></pre>

<h4 id="reporting-measure-run-method">Reporting Measure Run Method</h4>
<p>Reporting Measures are different than OpenStudio Measures or EnergyPlus Measures because they run after the simulation is complete. Therefore, there is not much of a point in changing the current OpenStudio Model or EnergyPlus Workspace. However, access to the last model or workspace is very useful for extracting information about the simulation. For these reasons, Reporting Measures allow access to a read only copy of the last OpenStudio Model generated in the simulation workflow as well as the last EnergyPlus Workspace simulated by EnergyPlus. Additionally, the EnergyPlus SqlFile containing tabular and timeseries simulation results is available along with the EpwFile that was simulated. All of these objects can be accessed from the runner as shown below:</p>
<pre><code class="ruby">  # define what happens when the measure is run
  def run(runner, user_arguments)
    super(runner, user_arguments)

    # use the built-in error checking
    if !runner.validateUserArguments(arguments(), user_arguments)
      return false
    end

    model = runner.lastOpenStudioModel
    if workspace.empty?
      runner.registerError(&quot;Cannot find last model.&quot;)
      return false
    end
    model = model.get

    workspace = runner.lastEnergyPlusWorkspace
    if workspace.empty?
      runner.registerError(&quot;Cannot find last workspace.&quot;)
      return false
    end
    workspace = workspace.get

    sqlFile = runner.lastEnergyPlusSqlFile
    if sqlFile.empty?
      runner.registerError(&quot;Cannot find last sql file.&quot;)
      return false
    end
    sqlFile = sqlFile.get

    epwFile = runner.lastEpwFile
    if epwFile.empty?
      runner.registerError(&quot;Cannot find last epw file.&quot;)
      return false
    end
    epwFile = epwFile.get
</code></pre>

<h3 id="output-attributes">Output Attributes</h3>
<p>We have seen how to output human readable messages from measures. These messages are useful when running and debugging measures manually using PAT. However, there is also a need to output machine readable attributes that can be used to create reports about design alternatives in parametric studies. Each attribute will be associated with the measure that generated it in the workflow. The registerValue method is used to register key value pairs:</p>
<pre><code class="ruby"># runner.registerValue(key,value,units)
runner.registerValue(&quot;total_life_cycle_cost&quot;, total_life_cycle_cost, &quot;$&quot;)
</code></pre>

<p>The key and units parameters must be strings, the value passed to registerValue can be a double, bool, integer, string, or nil object.</p>
<p>By default, all measure arguments are automatically output in machine readable format. For example, if a measure takes an argument named 'rotation':</p>
<pre><code class="ruby">relative_building_rotation = OpenStudio::Ruleset::OSArgument.makeDoubleArgument(&quot;rotation&quot;, true)
</code></pre>

<p>An attribute named 'rotation' will automatically be added to the measure's output with the value passed in by the user. Measure writers can output any attributes that they want to. If a measure outputs multiple attributes with the same name, the last attribute reported by that name will be preserved. Measure writers are encouraged to use terms that are present in the BCL taxonomy (and the upcoming DenCity Metadata API) to allow applications to understand attribute names. Additionally, special modifiers can be added to attribute names which will imply additional relationships between attributes. These special attribute modifiers are documented below, using the 'rotation' attribute.</p>
<table>
<thead>
<tr>
<th>Modifier</th>
<th>Example</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>*_initial</td>
<td>rotation_initial</td>
<td>The value of 'rotation' in the initial model before the measure was run.</td>
</tr>
<tr>
<td>*_final</td>
<td>rotation_final</td>
<td>The value of 'rotation' in the final model after the measure was run.</td>
</tr>
<tr>
<td></td>
<td></td>
<td>This should be reported even if the measure returns false or NA.</td>
</tr>
</tbody>
</table>

          <div class="footer">
  <p class="text-center"><a href="https://www.openstudio.net/contact">Contact Us</a></p>
  <p class="text-center"><a href="https://www.openstudio.net">OpenStudio</a> is developed in collaboration by NREL, ANL, LBNL, ORNL, and PNNL.</p>
  <p class="text-center"><a href="http://www.nrel.gov">NREL</a> is a National Laboratory of the U.S. Department of Energy, Office of Energy Efficiency and Renewable Energy, operated by the Alliance for Sustainable Energy, LLC.</p>
  <p class="text-center"><a href="#">Back to Top</a></p>
</div>
        </div>
      </div>
    </div>
    

    <script src="../../js/jquery-2.1.1.min.js"></script>
    <script src="../../js/bootstrap-3.3.0.min.js"></script>
    <script src="../../js/bootstrap-hover-dropdown-2.0.11.min.js"></script>
    <script src="../../js/prettify-1.0.min.js"></script>
    <script src="../../js/base.js"></script>
  </body>
</html>